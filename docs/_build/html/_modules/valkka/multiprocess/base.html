<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>valkka.multiprocess.base &mdash; Valkka_multiprocess  documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <!-- as per https://stackoverflow.com/questions/23211695/modifying-content-width-of-the-sphinx-theme-read-the-docs -->
    <link href="../../../_static/rtd_override.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
  <a href="../../../index.html"><img src="../../../_static/valkka.png" class="logo" alt="Logo"/>
</a>
    <div class="version">
      1.0.0
    </div>


<!-- font awesome comes with the rtd package.. use like this:-->
<a href="https://github.com/elsampsa/valkka_multiprocess" class="icon icon-github"> Valkka_multiprocess @ github</a>
<a href="https://github.com/elsampsa/valkka_multiprocess/issues" class="fa fa-bug"> Issue Tracker @ github</a>

<!-- don't even think about subclassing searchbox.html .. will never work!-->
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../requirements.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../submodules.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../article.html">Article</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Valkka_multiprocess</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">valkka.multiprocess.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for valkka.multiprocess.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;base.py : A simple multiprocessing framework with back- and frontend and pipes communicating between them</span>

<span class="sd">Copyright 2017-2023 Sampsa Riikonen</span>

<span class="sd">Authors: Sampsa Riikonen (sampsa.riikonen@iki.fi)</span>

<span class="sd">This particular file, referred below as &quot;Software&quot;, is licensed under the MIT LICENSE:</span>

<span class="sd">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without</span>
<span class="sd">restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom</span>
<span class="sd">the Software is furnished to do so, subject to the following conditions:</span>

<span class="sd">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>

<span class="sd">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE </span>
<span class="sd">AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, </span>
<span class="sd">ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">@file    base.py</span>
<span class="sd">@author  Sampsa Riikonen</span>
<span class="sd">@date    2020</span>
<span class="sd">@version 1.3.4 </span>

<span class="sd">@brief   A simple multiprocessing framework with back- and frontend and pipes communicating between them</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span>
<span class="kn">import</span> <span class="nn">select</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">signal</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># from valkka.api2.tools import getLogger, setLogger</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="safe_select"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.safe_select">[docs]</a><span class="k">def</span> <span class="nf">safe_select</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Like select.select, but ignores EINTR</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l3</span><span class="p">)</span> <span class="c1"># blocks</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="c1"># timeout 0 is just a poll</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="n">select</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># EINTR doesn&#39;t matter</span>
            <span class="k">return</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>  <span class="c1"># dont read socket</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>  <span class="c1"># read socket</span></div>


<div class="viewcode-block" id="MessageObject"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageObject">[docs]</a><span class="k">class</span> <span class="nc">MessageObject</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A generic MessageObject for intercommunication between</span>
<span class="sd">    fronend (main python process) and backend (forked multiprocess).</span>
<span class="sd">    </span>
<span class="sd">    Encapsulates a command and parameters</span>

<span class="sd">    :param command: the command</span>
<span class="sd">    :param kwargs: kwargs</span>

<span class="sd">    Example:</span>

<span class="sd">    ::</span>

<span class="sd">        msg = MessageObject(&quot;a-command&quot;, par1=1, par2=2)</span>
<span class="sd">        msg() # returns &quot;a-command&quot;</span>
<span class="sd">        msg[&quot;par1&quot;] # returns 1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">command</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;MessageObject: </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">command</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">command</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="MessageProcess"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess">[docs]</a><span class="k">class</span> <span class="nc">MessageProcess</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encapsulates:</span>

<span class="sd">    - Frontend methods (in the current main process)</span>
<span class="sd">    - Backend methods (that run in the background/forked process)</span>
<span class="sd">    - Intercom pipes that communicate (seamlessly) between the multiprocessing front- and backend</span>
<span class="sd">    - All intercom is encapsulated in ``MessageObject`` s</span>

<span class="sd">    When you send a ``MessageObject`` with command ``myStuff``, the forked multiprocess</span>
<span class="sd">    (aka backend) tries to find and execute the method ``c__myStuff`` in the backend.</span>

<span class="sd">    :param name: name of the multiprocess</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MessageProcess&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span> <span class="c1"># incoming messages &amp; pipe that is read by the main pythn process</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe_internal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe_internal</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span> <span class="c1"># used internally, for example, to wait results from the backend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listening</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># are we listening something else than just the intercom pipes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigint</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="MessageProcess.formatLogger"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.formatLogger">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">formatLogger</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper to setup logger formatter</span>

<span class="sd">        :param level: loglevel.  Default: ``logging.INFO``.</span>

<span class="sd">        Use only for initial development</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">logger</span><span class="o">.</span><span class="n">hasHandlers</span><span class="p">():</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(name)s</span><span class="s2"> - </span><span class="si">%(levelname)s</span><span class="s2"> - </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
            <span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="o">+</span><span class="s2">&quot;&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

<div class="viewcode-block" id="MessageProcess.preRun__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.preRun__">[docs]</a>    <span class="k">def</span> <span class="nf">preRun__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend method: subclass if needed</span>
<span class="sd">        </span>
<span class="sd">        Everything that needs to be done *after the fork* (i.e. in the backend), but *before*</span>
<span class="sd">        the multiprocesses&#39; main listening &amp; execution loop starts running.</span>

<span class="sd">        For example: import heavy libraries and instantiate deep neural net detectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="MessageProcess.postRun__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.postRun__">[docs]</a>    <span class="k">def</span> <span class="nf">postRun__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend method: subclass if needed</span>
<span class="sd">        </span>
<span class="sd">        Everything that needs to be done *after the fork* (i.e. in the backend), and right *after*</span>
<span class="sd">        the multiprocess has exited it&#39;s main listening &amp; execution loop, i.e. just before the multiprocess exits</span>
<span class="sd">        and dies.</span>

<span class="sd">        For example: clear heavy libraries and instantiate deep neural net detectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="c1"># **** backend ****</span>

<div class="viewcode-block" id="MessageProcess.run"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend method: the main listening &amp; execution loop.  Normally you would not subclass this one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigint</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_IGN</span><span class="p">)</span> <span class="c1"># handle in master process correctly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preRun__</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">listening</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">readPipes__</span><span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># timeout = 0 == just poll</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">readPipes__</span><span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span> <span class="c1"># timeout of 1 sec</span>
        <span class="c1"># indicate front end qt thread to exit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;bye!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postRun__</span><span class="p">()</span></div>


<div class="viewcode-block" id="MessageProcess.readPipes__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.readPipes__">[docs]</a>    <span class="k">def</span> <span class="nf">readPipes__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend method: listen simultaneously (i.e. &quot;multiplex&quot;) all intercom pipes.</span>

<span class="sd">        If you need to listen additionally anything else than the normal intercom pipe, please subclass this one.</span>

<span class="sd">        :param timeout: listening i/o timeout in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rlis</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="p">]</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">safe_select</span><span class="p">(</span><span class="n">rlis</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">)</span> <span class="c1"># timeout = 0 == this is just a poll</span>
        <span class="c1"># handle the main intercom pipe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handleBackPipe__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="p">)</span>    
            <span class="n">r</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="p">)</span></div>
        <span class="c1"># in your subclass, handle rest of the pipes</span>


    <span class="k">def</span> <span class="nf">handleBackPipe__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Route message to correct method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Reading pipe failed with </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">routeMainPipe__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">routeMainPipe__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Object from main pipe:</span>
<span class="sd">            </span>
<span class="sd">        - object.command</span>
<span class="sd">        - object.kwargs</span>
<span class="sd">        </span>
<span class="sd">        =&gt; route to &quot;self.c__command(**kwargs)&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>

        <span class="n">method_name</span> <span class="o">=</span> <span class="s2">&quot;c__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">command</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">method</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;routeMainPipe : could not call method </span><span class="si">%s</span><span class="s2"> with parameters </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;routeMainPipe : no such method </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">method_name</span><span class="p">))</span>


<div class="viewcode-block" id="MessageProcess.send_out__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.send_out__">[docs]</a>    <span class="k">def</span> <span class="nf">send_out__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend method: send an object from the backend to the frontend. </span>
<span class="sd">        It&#39;s recommended to use the ``MessageObject`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">return_out__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe_internal</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


    <span class="c1"># *** _your_ backend methods ***</span>

<div class="viewcode-block" id="MessageProcess.c__ping"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.c__ping">[docs]</a>    <span class="k">def</span> <span class="nf">c__ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lis</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;A demo multiprocessing backend method: triggered when frontend calls the method ``ping`` and sends a reply to frontend</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;c__ping:&quot;</span><span class="p">,</span> <span class="n">lis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_out__</span><span class="p">(</span><span class="n">MessageObject</span><span class="p">(</span><span class="s2">&quot;pong&quot;</span><span class="p">,</span> <span class="n">lis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span></div>


    <span class="c1"># **** frontend ****</span>

<div class="viewcode-block" id="MessageProcess.ignoreSIGINT"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.ignoreSIGINT">[docs]</a>    <span class="k">def</span> <span class="nf">ignoreSIGINT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: call before ``start`` (or ``go``), so that the multiprocess ignores all SIGINT signals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigint</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="MessageProcess.getPipe"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.getPipe">[docs]</a>    <span class="k">def</span> <span class="nf">getPipe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Pipe</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: returns the pipe you can use to listen to messages sent by the multiprocessing backend.</span>

<span class="sd">        returns a ``multiprocessing.Pipe`` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe</span></div>

<div class="viewcode-block" id="MessageProcess.sendMessageToBack"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.sendMessageToBack">[docs]</a>    <span class="k">def</span> <span class="nf">sendMessageToBack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">MessageObject</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: send a ``MessageObject`` to multiprocessing backend</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">returnFromBack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe_internal</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

<div class="viewcode-block" id="MessageProcess.go"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.go">[docs]</a>    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: a synonym to multiprocessing ``start()``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

<div class="viewcode-block" id="MessageProcess.requestStop"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.requestStop">[docs]</a>    <span class="k">def</span> <span class="nf">requestStop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: send a request to the multiprocess (backend) to stop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sendMessageToBack</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="MessageProcess.waitStop"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.waitStop">[docs]</a>    <span class="k">def</span> <span class="nf">waitStop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: alias to multiprocessing ``join()``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">()</span></div>

<div class="viewcode-block" id="MessageProcess.stop"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing frontend method: request backend multiprocess to stop and wait until it has finished</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">requestStop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waitStop</span><span class="p">()</span></div>

    <span class="c1"># *** _your_ frontend methods ***</span>

<div class="viewcode-block" id="MessageProcess.sendPing"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MessageProcess.sendPing">[docs]</a>    <span class="k">def</span> <span class="nf">sendPing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A demo multiprocessing frontend method: a demo method that sends the following ``MessageObject`` to the multiprocessing backend:</span>

<span class="sd">        .. code:: python</span>

<span class="sd">            MessageObject(</span>
<span class="sd">                &quot;ping&quot;,</span>
<span class="sd">                lis = lis</span>
<span class="sd">            ))</span>

<span class="sd">        In the backend this is mapped seamlessly into backend method ``c__ping``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sendMessageToBack</span><span class="p">(</span><span class="n">MessageObject</span><span class="p">(</span>
            <span class="s2">&quot;ping&quot;</span><span class="p">,</span>
            <span class="n">lis</span> <span class="o">=</span> <span class="n">lis</span>
            <span class="p">))</span></div></div>


<span class="c1"># Mixed sync/async processes</span>


<span class="k">def</span> <span class="nf">getPipes</span><span class="p">(</span><span class="n">block_A</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">block_B</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Either A or B can be blocking or non-blocking </span>

<span class="sd">    non-blocking pipe-terminal is required for asyncio</span>

<span class="sd">    ::</span>

<span class="sd">        A           B</span>

<span class="sd">        w --------&gt; r</span>
<span class="sd">        r &lt;-------- w</span>

<span class="sd">        (A_w, A_r) is returned as single duplex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B_read_fd</span><span class="p">,</span> <span class="n">A_write_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>
    <span class="n">A_read_fd</span><span class="p">,</span> <span class="n">B_write_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>
    <span class="c1">#print(&quot;read, write pair&quot;, B_read_fd, A_write_fd)</span>
    <span class="c1">#print(&quot;read, write pair&quot;, A_read_fd, B_write_fd)</span>
    <span class="c1"># these a file descriptors, i.e. numbers</span>

    <span class="k">if</span> <span class="n">block_A</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">A_read_fd</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">A_write_fd</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">A_read_fd</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">A_write_fd</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">block_B</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">B_read_fd</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">B_write_fd</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">B_read_fd</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">set_blocking</span><span class="p">(</span><span class="n">B_write_fd</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Duplex</span><span class="p">(</span><span class="n">A_read_fd</span><span class="p">,</span> <span class="n">A_write_fd</span><span class="p">),</span> <span class="n">Duplex</span><span class="p">(</span><span class="n">B_read_fd</span><span class="p">,</span> <span class="n">B_write_fd</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to8ByteMessage</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="c1"># r, w, e = safe_select([], [self.write_fd], [])</span>
    <span class="c1"># print(&quot;writing to&quot;, self.write_fd)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="c1"># length of the message, including the first 8 bytes</span>
    <span class="n">lenbytes</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span> <span class="o">=</span> <span class="s2">&quot;big&quot;</span><span class="p">)</span>
    <span class="n">n_pad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">val</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="n">val</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">n_pad</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lenbytes</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">pad</span>


<span class="k">class</span> <span class="nc">Duplex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates a duplex, similar to what you get from multiprocessing.Pipe(), but other side of the</span>
<span class="sd">    duplex is non-blocking (for asyncio backend)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">read_fd</span><span class="p">,</span> <span class="n">write_fd</span><span class="p">):</span>
        <span class="c1"># file descriptors, i.e. numbers:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_fd</span> <span class="o">=</span> <span class="n">read_fd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_fd</span> <span class="o">=</span> <span class="n">write_fd</span>
        <span class="c1"># these are _io.FileIO objects:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">read_fd</span><span class="p">,</span> <span class="s2">&quot;br&quot;</span><span class="p">,</span> <span class="n">buffering</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">write_fd</span><span class="p">,</span> <span class="s2">&quot;bw&quot;</span><span class="p">,</span> <span class="n">buffering</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">getReadIO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_io.FileIO object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span>

    <span class="k">def</span> <span class="nf">getReadFd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the file descriptor (int), aka &quot;fd&quot; for this pipe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fd</span>

    <span class="k">def</span> <span class="nf">getWriteFd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_fd</span>

    <span class="k">def</span> <span class="nf">getWriteIO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_io.FileIO object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span>

    <span class="k">def</span> <span class="nf">recv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Traditional blocking recv</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># print(&quot;waiting stream&quot;)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">+=</span> <span class="mi">8</span>
            <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># decode the first 8 bytes into int</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">byteorder</span> <span class="o">=</span> <span class="s2">&quot;big&quot;</span><span class="p">)</span>
                <span class="c1"># print(&quot;N&gt;&quot;, N)</span>
            <span class="c1"># print(res, len(res))</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="n">res</span>
            <span class="k">if</span> <span class="n">cc</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="c1"># remove any padding bytes</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tradition blocking send</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">to8ByteMessage</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># self.writer.flush() # no effect</span>
        <span class="c1"># print(&quot;wrote&quot;, n, &quot;bytes&quot;)</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="AsyncBackMessageProcess"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.AsyncBackMessageProcess">[docs]</a><span class="k">class</span> <span class="nc">AsyncBackMessageProcess</span><span class="p">(</span><span class="n">MessageProcess</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A subclass of ``MessageProcess``, but now the backend runs asyncio</span>

<span class="sd">    :param name: multiprocess name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;AsyncMessageProcess&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># self.front_pipe, self.back_pipe = getPipes(True, False) # blocking frontend, non-blocking backend (for asynchronous backend)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span> <span class="o">=</span> <span class="n">getPipes</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># both blocking: for testing # seems to make no difference (asyncio sets the pipes to non-blocking mode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listening</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># are we listening something else than just the intercom pipes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigint</span> <span class="o">=</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigint</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_IGN</span><span class="p">)</span> <span class="c1"># handle in master process correctly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preRun__</span><span class="p">()</span>
        <span class="c1"># very important! create a new separate event loop in the forked multiprocess</span>
        <span class="n">loop_</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop_</span><span class="p">)</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">async_run__</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postRun__</span><span class="p">()</span>


<div class="viewcode-block" id="AsyncBackMessageProcess.asyncPre__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.AsyncBackMessageProcess.asyncPre__">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncPre__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend coroutine: subclass if needed</span>
<span class="sd">        </span>
<span class="sd">        Everything that needs to be done *after the fork* (i.e. in the backend), but *before*</span>
<span class="sd">        the multiprocesses&#39; main asyncio event loop starts running.</span>

<span class="sd">        In addition to this, you can still subclass also ``preRun__`` that is executed</span>
<span class="sd">        after the fork but *before* the asyncio event loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="AsyncBackMessageProcess.asyncPost__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.AsyncBackMessageProcess.asyncPost__">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncPost__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend coroutine: subclass if needed</span>

<span class="sd">        Everything that needs to be done *after the fork* (i.e. in the backend), immediately </span>
<span class="sd">        before exiting the main asyncio event loop</span>

<span class="sd">        In addition to this, you can still subclass also ``postRun__`` that is executed</span>
<span class="sd">        after exiting the main syncio event loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="k">async</span> <span class="k">def</span> <span class="nf">async_run__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print(&quot;hello from async&quot;)</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

        <span class="c1"># arrange reading of the intercom pipe</span>
        <span class="n">back_reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="o">.</span><span class="n">getReadIO</span><span class="p">()</span>
        <span class="n">back_writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_pipe</span><span class="o">.</span><span class="n">getWriteIO</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stream_reader</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">StreamReader</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">protocol_factory</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">StreamReaderProtocol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream_reader</span><span class="p">)</span>
            
        <span class="sd">&quot;&quot;&quot;the logic here:</span>

<span class="sd">        read input (back_reader) is connected to the event loop, using</span>
<span class="sd">        a certain protocol .. protocol == what happens when there is</span>
<span class="sd">        stuff to read.  We&#39;ll do the reading &quot;manually&quot; in the loop,</span>
<span class="sd">        so nothing much</span>

<span class="sd">        same for writer.. we get writer_transport where we can write</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader_transport</span><span class="p">,</span> <span class="n">pro</span> <span class="o">=</span>\
            <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">connect_read_pipe</span><span class="p">(</span><span class="n">protocol_factory</span><span class="p">,</span> <span class="n">back_reader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer_transport</span><span class="p">,</span> <span class="n">pro</span> <span class="o">=</span>\
            <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">connect_write_pipe</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">BaseProtocol</span><span class="p">,</span> <span class="n">back_writer</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">asyncPre__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                <span class="s2">&quot;asyncPre__ failed with &#39;</span><span class="si">%s</span><span class="s2">&#39;:</span><span class="se">\</span>
<span class="s2">                don&#39;t call anything that requires intercom with the main loop&quot;</span><span class="p">,</span>
                <span class="n">e</span><span class="p">)</span>

        <span class="c1"># ..cause the loop starts over here:</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">:</span>
            <span class="c1"># TODO: we should not have any event/reading loops</span>
            <span class="c1"># when using asyncio, so this is a bit stupid</span>
            <span class="c1"># solution: define a proper protocol instead</span>
            <span class="c1">#</span>
            <span class="c1"># if you have file descriptors, add them to the event loop</span>
            <span class="c1"># like this: loop.add_reader(fd, callback, *args)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
            <span class="n">N</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># print(&quot;waiting stream&quot;)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
                <span class="n">cc</span> <span class="o">+=</span> <span class="mi">8</span>
                <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># decode the first 8 bytes into int</span>
                    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">byteorder</span> <span class="o">=</span> <span class="s2">&quot;big&quot;</span><span class="p">)</span>
                    <span class="c1"># print(&quot;N&gt;&quot;, N)</span>
                <span class="c1"># print(res, len(res))</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="n">res</span>
                <span class="k">if</span> <span class="n">cc</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="c1"># remove any padding bytes</span>
            <span class="c1">#&quot;&quot;&quot;</span>
            <span class="c1">#msg = await stream_reader.read(4096)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># print(&quot;obj&quot;, obj)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">routeMainPipe__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reader_transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer_transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">asyncPost__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;bye!&quot;</span><span class="p">)</span>
        

    <span class="k">async</span> <span class="k">def</span> <span class="nf">readPipes__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplex all intercom pipes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">BaseException</span><span class="p">(</span><span class="s2">&quot;not used&quot;</span><span class="p">))</span>


    <span class="k">async</span> <span class="k">def</span> <span class="nf">handleBackPipe__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Route message to correct method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Reading pipe failed with </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">routeMainPipe__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


    <span class="k">async</span> <span class="k">def</span> <span class="nf">routeMainPipe__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Object from main pipe:</span>
<span class="sd">            </span>
<span class="sd">        - object.command</span>
<span class="sd">        - object.kwargs</span>
<span class="sd">        </span>
<span class="sd">        =&gt; route to &quot;self.c__command(**kwargs)&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;routeMainPipe__&quot;, obj)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>

        <span class="n">method_name</span> <span class="o">=</span> <span class="s2">&quot;c__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">command</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
            <span class="c1"># print(&quot;method = &quot;, method)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">method</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;routeMainPipe : could not call method </span><span class="si">%s</span><span class="s2"> with parameters </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;routeMainPipe : no such method </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">method_name</span><span class="p">))</span>


<div class="viewcode-block" id="AsyncBackMessageProcess.send_out__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.AsyncBackMessageProcess.send_out__">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">send_out__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiprocessing backend coroutine: pickle obj &amp; send to main python process.</span>
<span class="sd">        It&#39;s recommended to use the ``MessageObject`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;send_out__&quot;, obj, self.writer_transport)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">to8ByteMessage</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="c1"># self.back_pipe.send(obj)</span>
        <span class="c1">#try:</span>
        <span class="c1"># print(&quot;send_out__&quot;, msg)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer_transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="c1"># woops.. this is _not_ async call (it returns immediately)</span></div>
        <span class="c1">#except Exception as e:</span>
        <span class="c1">#    print(&quot;send_out__ failed with&quot;, e)</span>
        <span class="c1">#print(&quot;send_out__: exit&quot;)</span>


    <span class="c1"># ***  _your_ backend methods ***</span>

<div class="viewcode-block" id="AsyncBackMessageProcess.c__ping"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.AsyncBackMessageProcess.c__ping">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">c__ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lis</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;A demo backend coroutine:  triggered when frontend calls the method ``ping`` and sends a reply to frontend</span>

<span class="sd">        So, in this coroutine it&#39;s all asyncio, i.e. await&#39;ing and sending tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;c__ping:&quot;</span><span class="p">,</span> <span class="n">lis</span><span class="p">)</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_out__</span><span class="p">(</span><span class="n">MessageObject</span><span class="p">(</span><span class="s2">&quot;pong&quot;</span><span class="p">,</span> <span class="n">lis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span></div>


    <span class="k">def</span> <span class="nf">sendMessageToBack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">MessageObject</span><span class="p">):</span>
        <span class="c1"># print(&quot;writing to&quot;, self.front_pipe.write_fd)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">front_pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>


<div class="viewcode-block" id="MainContext"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext">[docs]</a><span class="k">class</span> <span class="nc">MainContext</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A convenience class to organize your python main process in the context of multiprocessing</span>

<span class="sd">    You should subclass this.  In subclassed ``__init__``, you should always call the</span>
<span class="sd">    superclass constructor:</span>

<span class="sd">    ::</span>

<span class="sd">        def __init__(self):</span>
<span class="sd">            super().__init__()</span>

<span class="sd">    This will have the effect of calling ``startProcesses`` and ``startThreads``</span>
<span class="sd">    (see below).</span>

<span class="sd">    Please see tutorial, part II for practical subclassing examples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux_pipe_read</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_pipe_write</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>  <span class="c1"># when using runAsThread</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startProcesses</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startThreads</span><span class="p">()</span>

<div class="viewcode-block" id="MainContext.formatLogger"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.formatLogger">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">formatLogger</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper to setup logger formatter</span>

<span class="sd">        :param level: loglevel.  Default: ``logging.INFO``.</span>

<span class="sd">        Use only for initial development</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">logger</span><span class="o">.</span><span class="n">hasHandlers</span><span class="p">():</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(name)s</span><span class="s2"> - </span><span class="si">%(levelname)s</span><span class="s2"> - </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
            <span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

<div class="viewcode-block" id="MainContext.startProcesses"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.startProcesses">[docs]</a>    <span class="k">def</span> <span class="nf">startProcesses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mandatory. Create, cache and start your ``MessageProcess`` es here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;virtual method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MainContext.startThreads"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.startThreads">[docs]</a>    <span class="k">def</span> <span class="nf">startThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mandatory. Create, cache and start any python multithreads here if you have them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;virtual method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MainContext.close"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mandatory. Terminate all multiprocesses and threads.  Should be</span>
<span class="sd">        called in the ``__call__`` method after exiting the main loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;virtual method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MainContext.__call__"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mandatory.  Your main process loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;alive&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;you pressed CTRL-C: will exit asap&quot;</span><span class="p">)</span>
                <span class="k">break</span></div>

<div class="viewcode-block" id="MainContext.runAsThread"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.runAsThread">[docs]</a>    <span class="k">def</span> <span class="nf">runAsThread</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the class as a thread.  Only for testing/debugging purposes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;starting as thread&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c1"># goes into background</span></div>

<div class="viewcode-block" id="MainContext.stopThread"><a class="viewcode-back" href="../../../submodules.html#valkka.multiprocess.base.MainContext.stopThread">[docs]</a>    <span class="k">def</span> <span class="nf">stopThread</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If launched with ``runAsThread``, use this method to stop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;requesting thread stop&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux_pipe_write</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;thread stopped&quot;</span><span class="p">)</span></div></div>



<span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">MessageProcess</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">go</span><span class="p">()</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getPipe</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sending ping&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendPing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">AsyncBackMessageProcess</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">go</span><span class="p">()</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getPipe</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># print(&quot;sending some to&quot;, pipe.write_fd)</span>
    <span class="c1"># pipe.send(&quot;kokkelis&quot;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sending ping&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendPing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&gt; got&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sending another ping&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendPing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="c1">#p.sendPing([1,2,3])</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sending stop&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># test1()</span>
    <span class="n">test2</span><span class="p">()</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2023 Sampsa Riikonen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>